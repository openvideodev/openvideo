import { z } from 'genkit';
import { ai } from './chat-flow';

// Lazy tool initialization to prevent re-registration errors
let toolsCache: any[] | null = null;

export function getTools() {
  if (toolsCache) return toolsCache;

  const add_text = ai.defineTool(
    {
      name: 'add_text',
      description: 'Add a text element to the video timeline',
      inputSchema: z.object({
        text: z.string().describe('The text content to display'),
        targetId: z
          .string()
          .optional()
          .describe('The unique ID for this new asset (generated by you)'),
        from: z
          .number()
          .default(0)
          .describe('Start time in seconds (default 0)'),
        to: z.number().default(5).describe('End time in seconds (default 0)'),
      }),
      outputSchema: z.object({
        targetId: z.string(),
        message: z.string(),
      }),
    },
    async ({ text, targetId, from, to }) => {
      console.log('text: ', { text, targetId, from, to });
      return {
        targetId: targetId || 'temp_id',
        message: `Text added: ${text}`,
      };
    }
  );

  const add_image = ai.defineTool(
    {
      name: 'add_image',
      description: 'Generate an image or add an image based on a prompt',
      inputSchema: z.object({
        prompt: z
          .string()
          .describe('Detailed description of the image to generate or add'),
        url: z.string().optional().describe('URL of the image if available'),
        targetId: z
          .string()
          .optional()
          .describe('The unique ID for this new asset'),
        from: z
          .number()
          .default(0)
          .describe('Start time in seconds (default 0)'),
        to: z.number().default(5).describe('End time in seconds (default 0)'),
      }),
      outputSchema: z.object({
        targetId: z.string(),
        message: z.string(),
      }),
    },
    async ({ prompt, targetId }) => {
      return {
        targetId: targetId || 'temp_id',
        message: `ðŸ–¼ Image created/added with prompt "${prompt}"`,
      };
    }
  );

  const add_video = ai.defineTool(
    {
      name: 'add_video',
      description: 'Add a video based on a prompt or URL',
      inputSchema: z.object({
        prompt: z.string().describe('Detailed description of the video to add'),
        url: z.string().optional().describe('URL of the video if available'),
        targetId: z
          .string()
          .optional()
          .describe('The unique ID for this new asset'),
        from: z.number().optional().describe('Start time in seconds'),
        to: z.number().optional().describe('End time in seconds'),
      }),
      outputSchema: z.object({
        targetId: z.string(),
        message: z.string(),
      }),
    },
    async ({ prompt, targetId }) => {
      return {
        targetId: targetId || 'temp_id',
        message: `ðŸŽ¬ Video added with prompt "${prompt}"`,
      };
    }
  );

  const add_audio = ai.defineTool(
    {
      name: 'add_audio',
      description: 'Add audio or music to the video',
      inputSchema: z.object({
        prompt: z.string().describe('Description of the audio or music to add'),
        url: z.string().optional().describe('URL of the audio if available'),
        targetId: z
          .string()
          .optional()
          .describe('The unique ID for this new asset'),
        from: z.number().optional().describe('Start time in seconds'),
        to: z.number().optional().describe('End time in seconds'),
      }),
      outputSchema: z.object({
        targetId: z.string(),
        message: z.string(),
      }),
    },
    async ({ prompt, targetId }) => {
      return {
        targetId: targetId || 'temp_id',
        message: `ðŸŽµ Audio added with prompt "${prompt}"`,
      };
    }
  );

  const update_clip = ai.defineTool(
    {
      name: 'update_clip',
      description: 'Update properties of an existing clip',
      inputSchema: z.object({
        targetId: z.string().describe('The ID of the clip to update'),
        left: z.number().optional(),
        top: z.number().optional(),
        width: z.number().optional(),
        height: z.number().optional(),
        start: z.number().optional().describe('Start time in seconds'),
        fontSize: z.number().optional().describe('Font size for text clips'),
        fontFamily: z
          .string()
          .optional()
          .describe('Font family for text clips'),
        fill: z.string().optional().describe('Text color in hex format'),
        opacity: z.number().optional().describe('Opacity from 0 to 1'),
        volume: z.number().optional().describe('Volume from 0 to 1'),
        playbackRate: z.number().optional().describe('Playback rate'),
      }),
      outputSchema: z.object({
        targetId: z.string(),
        message: z.string(),
      }),
    },
    async ({ targetId }) => {
      return {
        targetId,
        message: `Clip ${targetId} updated`,
      };
    }
  );

  const remove_clip = ai.defineTool(
    {
      name: 'remove_clip',
      description: 'Remove a clip from the timeline',
      inputSchema: z.object({
        targetId: z.string().describe('The ID of the clip to remove'),
      }),
      outputSchema: z.object({
        targetId: z.string(),
        message: z.string(),
      }),
    },
    async ({ targetId }) => {
      return {
        targetId,
        message: `Clip ${targetId} removed`,
      };
    }
  );

  const split_clip = ai.defineTool(
    {
      name: 'split_clip',
      description: 'Split a clip at a specific time',
      inputSchema: z.object({
        targetId: z.string().describe('The ID of the clip to split'),
        time: z.number().optional().describe('The time in seconds to split at'),
      }),
      outputSchema: z.object({
        targetId: z.string(),
        message: z.string(),
      }),
    },
    async ({ targetId, time }) => {
      return {
        targetId,
        message: `Clip ${targetId} split at ${time} seconds`,
      };
    }
  );

  const add_transition = ai.defineTool(
    {
      name: 'add_transition',
      description: 'Add a transition between two clips',
      inputSchema: z.object({
        fromId: z.string().describe('Source clip ID'),
        toId: z.string().describe('Target clip ID'),
        transitionType: z
          .string()
          .default('fade')
          .describe('Type of transition (e.g., fade, slide)'),
      }),
      outputSchema: z.object({
        message: z.string(),
      }),
    },
    async ({ fromId, toId, transitionType }) => {
      return {
        message: `Transition ${transitionType} added between ${fromId} and ${toId}`,
      };
    }
  );

  const add_effect = ai.defineTool(
    {
      name: 'add_effect',
      description: 'Add a visual effect to a clip',
      inputSchema: z.object({
        //targetId: z.string().optional().describe("The ID of the clip"),
        effectName: z
          .string()
          .default('glitch')
          .describe('Name of the effect (e.g., glitch, sepia)'),
        from: z.number().optional().describe('Start time in seconds'),
        to: z.number().optional().describe('End time in seconds'),
      }),
      outputSchema: z.object({
        targetId: z.string().optional(),
        message: z.string(),
      }),
    },
    async ({ effectName }) => {
      return {
        message: `Effect ${effectName} added`,
      };
    }
  );

  const duplicate_clip = ai.defineTool(
    {
      name: 'duplicate_clip',
      description: 'Duplicate a specific clip or the selected ones',
      inputSchema: z.object({
        targetId: z
          .string()
          .optional()
          .describe('The ID of the clip to duplicate'),
      }),
      outputSchema: z.object({
        message: z.string(),
      }),
    },
    async ({ targetId }) => {
      return {
        message: targetId
          ? `Clip ${targetId} duplicated`
          : 'Selected clips duplicated',
      };
    }
  );

  const trim_clip = ai.defineTool(
    {
      name: 'trim_clip',
      description: 'Trim a clip to a specific range',
      inputSchema: z.object({
        targetId: z.string().optional().describe('The ID of the clip to trim'),
        trimFrom: z
          .number()
          .describe(
            "The new start time in seconds relative to the clip's source"
          ),
      }),
      outputSchema: z.object({
        message: z.string(),
      }),
    },
    async ({ targetId, trimFrom }) => {
      return {
        message: `Clip ${targetId || 'selected'} trimmed from ${trimFrom}`,
      };
    }
  );

  const search_and_add_media = ai.defineTool(
    {
      name: 'search_and_add_media',
      description: 'Search for and add stock media (video/image) from Pexels',
      inputSchema: z.object({
        query: z.string().describe('Search terms for the media'),
        type: z
          .enum(['video', 'image'])
          .default('video')
          .describe('Type of media'),
        targetId: z.string().optional().describe('Unique ID for the new clip'),
        from: z.number().optional().describe('Start time in seconds'),
      }),
      outputSchema: z.object({
        message: z.string(),
      }),
    },
    async ({ query, type }) => {
      return { message: `Searching for ${type} with query "${query}"` };
    }
  );

  const generate_voiceover = ai.defineTool(
    {
      name: 'generate_voiceover',
      description: 'Generate a voiceover using ElevenLabs',
      inputSchema: z.object({
        text: z.string().describe('Text to convert to speech'),
        voiceId: z.string().optional().describe('Optional voice ID to use'),
        targetId: z.string().optional().describe('Unique ID for the new clip'),
        from: z.number().optional().describe('Start time in seconds'),
      }),
      outputSchema: z.object({
        message: z.string(),
      }),
    },
    async ({ text }) => {
      return { message: `Generating voiceover for: "${text}"` };
    }
  );

  const seek_to_time = ai.defineTool(
    {
      name: 'seek_to_time',
      description: 'Move the playhead to a specific time',
      inputSchema: z.object({
        time: z.number().describe('Time in seconds to seek to'),
      }),
      outputSchema: z.object({
        message: z.string(),
      }),
    },
    async ({ time }) => {
      return { message: `Seeking to ${time} seconds` };
    }
  );

  const generate_captions = ai.defineTool(
    {
      name: 'generate_captions',
      description: 'Generate captions for the video or specific clips',
      inputSchema: z.object({
        clipIds: z
          .array(z.string())
          .optional()
          .describe('Specific clips to transcribe'),
      }),
      outputSchema: z.object({
        message: z.string(),
      }),
    },
    async () => {
      return { message: 'Generating captions' };
    }
  );

  const fallback = ai.defineTool(
    {
      name: 'fallback',
      description:
        'Use this tool when you cannot perform the requested action with the available tools.',
      inputSchema: z.object({
        friendlyMessage: z
          .string()
          .describe(
            "A friendly explanation of why the action cannot be performed, in the user's language."
          ),
      }),
      outputSchema: z.object({
        success: z.boolean(),
      }),
    },
    async ({ friendlyMessage }) => {
      return { success: true };
    }
  );

  toolsCache = [
    add_text,
    add_image,
    add_video,
    add_audio,
    update_clip,
    remove_clip,
    split_clip,
    trim_clip,
    duplicate_clip,
    add_transition,
    add_effect,
    search_and_add_media,
    generate_voiceover,
    seek_to_time,
    generate_captions,
    fallback,
  ];

  return toolsCache;
}
